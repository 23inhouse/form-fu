#
# This file has the module FormFu::FormFuBuilderMethods which when included in a class* adds the 
# convenience methods (..._form_for, etc...) and adds the form_fu goodness.
#
# *Note: classes must inherit from ActionView::Helpers::FormBuilder.
#
module FormFu #:nodoc:
  module FormFuBuilderMethods
    include ActionView::Helpers::JavaScriptHelper
    
    def self.included(klass) #:nodoc:
      self.included_in_classes.each do |builder_class_name|
        builder_name = /FormFu::(.+?)FormBuilder/.match(builder_class_name.to_s)[1].underscore
        unless ActionView::Base.method_defined?("#{builder_name}_form_for")
          [:form_for, :fields_for, :form_remote_for, :remote_fields_for].each do |meth|
            src = <<-end_src
              def #{builder_name}_#{meth}(record_or_name_or_array, *args, &proc)
                options = args.last.is_a?(Hash) ? args.pop : {}
                options.merge!(:builder => #{builder_class_name.to_s.demodulize})
                #{meth}(record_or_name_or_array, *(args << options), &proc)
              end
            end_src
            ActionView::Base.class_eval src, __FILE__, __LINE__
          end
          
          ActionView::Base.class_eval do
            def options_to_attrs(options)
              (options || {}).inject([]) { |a,i| a << %(#{i[0]}="#{i[1]}") }.join(' ')
            end
          end
        end
      end
      
      klass.class_eval do
        alias_method_chain :check_box, :form_fu
        alias_method_chain :check_boxes, :form_fu
        alias_method_chain :date_select, :form_fu
        alias_method_chain :datetime_select, :form_fu
        alias_method_chain :file_field, :form_fu
        alias_method_chain :password_field, :form_fu
        alias_method_chain :radio_button, :form_fu
        alias_method_chain :radio_buttons, :form_fu
        alias_method_chain :select, :form_fu
        alias_method_chain :time_select, :form_fu
        alias_method_chain :text_area, :form_fu
        alias_method_chain :text_field, :form_fu
      end
    end
    
    attr_accessor :disabled, :report
    
    # Returns the html from your fieldset_wrapper partial in your builder folder inside the
    # <tt>app/views/form_fu/</tt> folder.  So if you are using the uni_form_for it will use the partial
    # /app/views/form_fu/uni/_fieldset.html.erb
    #
    # ==== Examples
    #   f.fields do 
    #     f.text_field(:my_column)
    #   end
    #   # => <fieldset>
    #   # =>   <ul>
    #   # =>     <li><input type="text" value="" name="my_model[my_column]"/></li> # this line is generated by the f.text_field method
    #   # =>   </ul>
    #   # => </fieldset>
    def fields(*args, &block)
      options = args.extract_options!
      html_options = options[:html] || {}
      
      @disabled = options.delete(:disabled) || @options.has_key?(:disabled)
      @report = options.delete(:report) || @options.has_key?(:report)

      contents = @template.capture(&block)
      fieldset = fieldset_wrapper(contents, options, html_options)
      @template.concat(fieldset)
    end

    # Returns a div tag with the content you pass to it in the block
    #
    # ==== Examples
    #   f.buttons do 
    #     My buttons
    #   end
    #   # => <div class="buttons">
    #   # =>   My buttons
    #   # => </div>
    def buttons(*args, &block)
      options = args.extract_options!
      html_options = options[:html] || {}

      contents = @template.capture(&block)
      buttonset = buttonset_wrapper(contents, options, html_options)
      @template.concat(buttonset)
    end

    # Replicating the functionality of the <button> tag, this is because IE can't do button tags. For
    # instance, if you wanted the functionality at <button> tag like this:
    #
    # <tt><button type="submit" value="my_submit_value" name="my_submit">Microsoft sucks it</button></tt>
    #
    # You can do this:
    #
    #   submit_button("Microsoft sucks it", {:name => 'my_submit', :value => 'my_submit_value'})
    #   # => <input type="submit" value="Microsoft sucks it" class="submit" name="my_submit"/> 
    #   # => <input class="m013573d_by_IE" type="hidden" value="my_submit_value" name="_Microsoft sucks it"/>
    #
    # Now, in the controller you can match the button "Microsoft sucks it" to the value "my_submit_value"
    #
    def submit_button(display = "Save changes", options = {})
      name = options.delete(:name)
      value = options.delete(:value)
      options[:class] = ([options[:class]].reject { |a| a.blank? } << 'submit').join(' ')
      input_tag = @template.tag(:input, {:type => "submit", :name => name, :value => display, :class => "submit"}.merge(options.stringify_keys))
      hidden_tag = (value) ? @template.tag(:input, {:type => "hidden", :name => "_#{display}", :value => value, :class => "m013573d_by_IE"}.merge(options.stringify_keys)) : ''
      "#{input_tag} #{hidden_tag}"
    end
    
    # Returns an input tag of the "button" type and a javascript tag that binds the events using jQuery
    #
    # ==== Examples
    #   confirm_button()
    #   # => <input type="submit" value="Kill the baby seal" class="confirm"/>
    #   # => <script type="text/javascript">
    #   # => //<![CDATA[
    #   # =>   jQuery("input[value=Kill the baby seal]").bind('click', function() {
    #   # =>     return confirm("Are you sure you want to kill the baby seal?") ? true : false;
    #   # =>   })
    #   # => //]]>
    #
    # With custom text
    #
    #   confirm_button('Delete', 'Are you sure you want to delete it?')
    #   # => <input type="submit" value="Kill the baby seal" class="confirm"/>
    #   # => <script type="text/javascript">
    #   # => //<![CDATA[
    #   # =>   jQuery("input[value=Delete]").bind('click', function() {
    #   # =>     return confirm("Are you sure you want to delete it?") ? true : false;
    #   # =>   })
    #   # => //]]>
    def confirm_button(display = "Kill the baby seal", confirm_message = "Are you sure you want to kill the baby seal?", options = {})
      name = options.delete(:name)
      value = options.delete(:value)
      options[:class] = ([options[:class]].reject { |a| a.blank? } << 'confirm').join(' ')
      input_tag = @template.tag(:input, {:type => "submit", :name => name, :value => display}.merge(options.stringify_keys))
      hidden_tag = (value) ? @template.tag(:input, {:type => "hidden", :name => "_#{display}", :value => value, :class => "m013573d_by_IE"}.merge(options.stringify_keys)) : ''
      filter = options.has_key?('id') ? "##{options['id']}" : "input[value=#{display}]"
      script_tag = @template.javascript_tag(%(jQuery("#{filter}").bind('click', function() { return confirm("#{escape_javascript(confirm_message)}") ? true : false; })));
      "#{input_tag} #{hidden_tag} #{script_tag}"
    end
    
    # Returns an input tag of the "button" type and a javascript tag that binds the events using jQuery
    #
    # ==== Examples
    #   bind_button("Cancel", {:click => "location.href = 'link_location'"})
    #   # => <input type="button" value="Cancel" class="bind"/>
    #   # => <script type="text/javascript">
    #   # => //<![CDATA[
    #   # =>   jQuery("input[value=Cancel]").bind('click', function() { location.href = 'link_location' })
    #   # => //]]>
    #   # => </script>
    
    def bind_button(value = "Save changes", events = {}, options = {})
      options[:class] = ([options[:class]].reject { |a| a.blank? } << 'bind').join(' ')
      input_tag = @template.tag(:input, {:type => "button", :value => value}.merge(options.stringify_keys))
      filter = options.has_key?('id') ? "##{options['id']}" : "input[value=#{value}]"
      bind_functions = [%(jQuery("#{filter}"))]
      events.each do |event, function|
        bind_functions << %(('#{event}', function() { #{function} }))
      end
      script_tag = @template.javascript_tag(bind_functions.join('.bind'))
      "#{input_tag} #{script_tag}"
    end
    
    def field_error(method) #:nodoc:
      errors = errors(method)
      unless report || errors.blank?
        errors = (errors.class == Array) ? errors.first : errors
        error_message = (errors.mb_chars[0...1] == '^') ? errors.mb_chars[1..-1] : "#{@object.class.human_attribute_name(method.to_s)} #{errors}"
        @template.content_tag('p', error_message, :class => "errorMessage")
      else
        ""
      end
    end

    def field_label(method, text = nil, options = {}) #:nodoc:
      merge_options = {:object => @object}
      merge_options[:class] = 'error' unless errors(method).blank?
      merge_options[:required] = options.key?(:required) ? options[:required] : method_required?(method)
      @template.field_label(@object_name, method, text, options.merge(merge_options))
    end
    
  private
    
    def errors(method) #:nodoc:
      obj = @object || @template.instance_variable_get("@#{@object_name}")
      obj.errors.on(method) unless obj.nil?
    end
    
    def method_required?(attribute) #:nodoc:
      if @object && @object.class.respond_to?(:reflect_on_validations_for)
        attribute_sym = attribute.to_s.sub(/_id$/, '').to_sym

        @object.class.reflect_on_validations_for(attribute_sym).any? do |validation|
          (validation.macro == :validates_presence_of || validation.macro == :validates_acceptance_of) &&
          validation.name == attribute_sym &&
          (validation.options.present? ? options_require_validation?(validation.options) : true)
        end
      end
    end
    
    # Determines whether the given options evaluate to true
    def options_require_validation?(options) #:nodoc:
      if_condition = !options[:if].nil?
      condition = if_condition ? options[:if] : options[:unless]

      condition = if condition.respond_to?(:call)
                    condition.call(@object)
                  elsif condition.is_a?(::Symbol) && @object.respond_to?(condition)
                    @object.send(condition)
                  else
                    condition
                  end

      if_condition ? !!condition : !condition
    end
    
    def html_attrs #:nodoc:
      [:abbr, 'accept-charset', :accept, :accesskey, :action, :align, :alink, :alt, :archive, :archive, :axis, :background, :bgcolor, :border, :cellpadding, :cellspacing, :char, :charoff, :charset, :checked, :cite, :class, :classid, :clear, :code, :codebase, :codetype, :color, :cols, :colspan, :compact, :content, :contenteditable, :coords, :data, :datafld, :dataformatas, :datasrc, :datetime, :declare, :defer, :dir, :disabled, :enctype, :face, :for, :frame, :frameborder, :headers, :height, :hidefocus, :href, :hreflang, :hspace, 'http-equiv', :id, :ismap, :label, :lang, :language, :link, :longdesc, :longdesc, :marginheight, :marginwidth, :maxlength, :media, :method, :multiple, :name, :nohref, :noresize, :noshade, :nowrap, :object, :onblur, :onchange, :onclick, :ondblclick, :onfocus, :onkeydown, :onkeypress, :onkeyup, :onload, :onload, :onmousedown, :onmousemove, :onmouseout, :onmouseover, :onmouseup, :onreset, :onselect, :onsubmit, :onunload, :onunload, :profile, :prompt, :readonly, :rel, :rev, :rows, :rowspan, :rules, :scheme, :scope, :scrolling, :selected, :shape, :size, :span, :src, :standby, :start, :style, :summary, :tabindex, :target, :text, :title, :type, :unselectable, :usemap, :valign, :value, :valuetype, :version, :vlink, :vspace, :width]
    end
    
    def mixin_options(selector, options = {}) #:nodoc:
      options.merge!({:report => true}) unless report.blank? || options[:report] == false
      options.merge!({:disabled => true}) unless disabled.blank? || options[:disabled] == false
      options.merge!({:selector => selector})
      options
    end

    def clean_options(options = {}) #:nodoc:
      options.reject { |k,v| (html_attrs + [:required, :builder]).include?(k) }
    end

    def submit_script #:nodoc:
      @template.javascript_tag %(
        jQuery(document).ready(function() {
        	jQuery('input.submit').bind('keypress', function(e) { if(e.keyCode == 13) { return false; } }).each(function() {
        	  jQuery(this).closest('form').submit(function(e) {
              jQuery(e.originalEvent.explicitOriginalTarget).attr('value', 'Please wait...');
              jQuery('input.submit', this).each(function() { jQuery(this).attr('disabled', 'disabled'); })
            })
        	})
        });
      )
    end

    %w(file_field text_field password_field text_area).each do |selector|
      src = <<-end_src
        def #{selector}_with_form_fu(method, options = {}) #:nodoc:
          mixin_options(:#{selector}, options)
          field_wrapper(method, options, #{selector}_without_form_fu(method, options))
        end
      end_src
      class_eval src, __FILE__, __LINE__
    end

    %w(check_boxes radio_buttons select).each do |selector|
      src = <<-end_src
        def #{selector}_with_form_fu(method, choices, options = {}, html_options = {}) #:nodoc:
          mixin_options(:#{selector}, options)
          field_wrapper(method, options, #{selector}_without_form_fu(method, choices, options, html_options))
        end
      end_src
      class_eval src, __FILE__, __LINE__
    end

    %w(date_select datetime_select time_select).each do |selector|
      src = <<-end_src
        def #{selector}_with_form_fu(method, options = {}, html_options = {}) #:nodoc:
          mixin_options(:#{selector}, options)
          field_wrapper(method, options, #{selector}_without_form_fu(method, options, html_options))
        end
      end_src
      class_eval src, __FILE__, __LINE__
    end

    def check_box_with_form_fu(method, options = {}, checked_value = "1", unchecked_value = "0") #:nodoc:
      mixin_options(:check_box, options)
      field_wrapper(method, options, check_box_without_form_fu(method, options, checked_value, unchecked_value))
    end

    def radio_button_with_form_fu(method, tag_value, options = {}) #:nodoc:
      mixin_options(:radio_button, options)
      field_wrapper(method, options, radio_button_without_form_fu(method, tag_value, options))
    end
  end
end
